# This is a simple script to scan for software vulnerabilities on a Windows 11 Machine.
# It will scan for vulnerabilities on the machine and return a list of software, software version,vulnerabilities, severity, and CVE citation.

# This script will use the following API:
# https://nvd.nist.gov/developers/request-an-api-key

# Software Vulnerability Scanner for Windows 11
# Uses NVD API for comprehensive vulnerability data

# Configuration
$apiKey = (Get-Content -Path "configVuln.json" | ConvertFrom-Json).NVDAPIKey    
$nvdApiBase = "https://services.nvd.nist.gov/rest/json/cves/2.0"

# Function to get installed software
function Get-InstalledSoftware {
    Write-Host "Getting installed software from winget..."
    
    try {
        # Get the raw winget output similar to AppUpdateCheck.ps1
        $wingetOutput = winget list --name --id --version | Out-String
        
        # Convert the output to an array of lines and clean it up
        $lines = $wingetOutput -split "`n" | Where-Object { $_ -match '\S' }
        
        # Find the header line
        $headerIndex = $lines | Select-Object -First 5 | 
            Where-Object { $_ -match 'Name.*Version' } |
            ForEach-Object { $lines.IndexOf($_) }
        
        if ($null -eq $headerIndex) {
            throw "Could not find header in winget output"
        }
        
        # Skip header and separator lines
        $results = for ($i = $headerIndex + 2; $i -lt $lines.Count; $i++) {
            $line = $lines[$i]
            if ($line -match '^\s*$') { continue }
            
            # Split line by multiple spaces
            $parts = $line -split '\s{2,}'
            if ($parts.Count -ge 3) {
                [PSCustomObject]@{
                    Name = $parts[0].Trim()
                    ID = $parts[1].Trim()
                    Version = $parts[2].Trim()
                    Source = "Winget"
                }
            }
        }
        
        # Format and display the results
        $results | Format-Table -AutoSize -Property @(
            @{Label="Software Name"; Expression={$_.Name}},
            @{Label="ID"; Expression={$_.ID}},
            @{Label="Version"; Expression={$_.Version}}
        )
        
        return $results
    }
    catch {
        Write-Error "Error getting installed software: $_"
        return $null
    }
}

# Helper function to parse winget output
function Parse-WingetOutput {
    param (
        [string]$wingetOutput
    )
    
    # Convert the output to an array of lines and clean it up
    $lines = $wingetOutput -split "`n" | Where-Object { $_ -match '\S' }
    
    # Find the header line (contains "Name" and "Version")
    $headerIndex = $lines | Select-Object -First 5 | 
        Where-Object { $_ -match 'Name.*Version' } |
        ForEach-Object { $lines.IndexOf($_) }
    
    # Get the separator line to determine column positions
    $separator = $lines[$headerIndex + 1]
    
    # Create regex pattern based on separator line
    $columnBreaks = @()
    $separator.ToCharArray() | ForEach-Object -Begin { $i = 0 } -Process {
        if ($_ -eq '-' -and ($i -eq 0 -or $separator[$i-1] -ne '-')) {
            $columnBreaks += $i
        }
        $i++
    }
    $columnBreaks += $separator.Length
    
    # Process each line after the separator
    $results = for ($i = $headerIndex + 2; $i -lt $lines.Count; $i++) {
        $line = $lines[$i]
        if ($line -match '^\s*$') { continue }
        
        try {
            # Safely get substrings with error checking
            $nameLength = $columnBreaks[1] - $columnBreaks[0]
            $idLength = $columnBreaks[2] - $columnBreaks[1]
            $versionLength = $columnBreaks[3] - $columnBreaks[2]
            
            if ($nameLength -gt 0 -and $line.Length -gt $columnBreaks[0]) {
                $name = $line.Substring($columnBreaks[0], [Math]::Min($nameLength, $line.Length - $columnBreaks[0])).Trim()
                $id = if ($idLength -gt 0 -and $line.Length -gt $columnBreaks[1]) {
                    $line.Substring($columnBreaks[1], [Math]::Min($idLength, $line.Length - $columnBreaks[1])).Trim()
                } else { "" }
                $version = if ($versionLength -gt 0 -and $line.Length -gt $columnBreaks[2]) {
                    $line.Substring($columnBreaks[2], [Math]::Min($versionLength, $line.Length - $columnBreaks[2])).Trim()
                } else { "" }
                
                [PSCustomObject]@{
                    Name = $name
                    ID = $id
                    Version = $version
                    InstallDate = (Get-Item (Get-Command ($name -replace '\s.*$','')).Source -ErrorAction SilentlyContinue).CreationTime
                    Source = "Winget"
                }
            }
        }
        catch {
            Write-Warning "Error processing line: $line"
            Write-Warning $_.Exception.Message
            continue
        }
    }
    
    return $results
}

# Function to query NVD API
function Get-VulnerabilityData {
    param (
        [string]$software,
        [string]$version
    )
    
    # Remove any special characters and trim the software name
    $cleanSoftware = $software -replace '[^\w\s]', '' -replace '\s+', ' '
    
    $uri = "$nvdApiBase?keywordSearch=$cleanSoftware&apiKey=$apiKey"
    
    try {
        # Add error handling for empty or null software names
        if ([string]::IsNullOrWhiteSpace($cleanSoftware)) {
            Write-Warning "Empty software name provided"
            return $null
        }

        $response = Invoke-RestMethod -Uri $uri -Method Get
        
        # Check if we got a valid response
        if ($response.vulnerabilities) {
            return $response.vulnerabilities | Where-Object {
                $_.cve.descriptions.value -like "*$cleanSoftware*"
            }
        } else {
            Write-Verbose "No vulnerabilities found for $cleanSoftware"
            return $null
        }
    }
    catch {
        Write-Warning "Error querying NVD API for $cleanSoftware`: $_"
        return $null
    }
}

# Main scanning logic
write-host "Scanning for installed software..."
$startTime = Get-Date

try {
    $installedSoftware = Get-InstalledSoftware
    if ($null -eq $installedSoftware) {
        throw "No software found"
    }
    
    $totalApps = ($installedSoftware | Measure-Object).Count
    write-host "`nFound $totalApps applications to scan"

    write-host "`nScanning for vulnerabilities..."
    $progress = 0
    
    foreach ($software in $installedSoftware) {
        $progress++
        # Add null check for software name
        $statusMessage = if ([string]::IsNullOrWhiteSpace($software.Name)) {
            "Scanning Unknown Application"
        } else {
            "Scanning $($software.Name)"
        }
        
        Write-Progress -Activity "Scanning Software" -Status $statusMessage `
            -PercentComplete (($progress / $totalApps) * 100)
            
        if (![string]::IsNullOrWhiteSpace($software.Name)) {
            $vulnerabilityData = Get-VulnerabilityData -software $software.Name -version $software.Version
            if ($vulnerabilityData) {
                Write-Host "`nFound vulnerabilities for $($software.Name):"
                $vulnerabilityData | Select-Object -Property Name, Version, Vulnerability, Severity, CVE | 
                    Format-Table -AutoSize
            }
        }
        
        # Add delay to respect API rate limits
        Start-Sleep -Milliseconds 1200  # ~50 requests per minute
    }

    $endTime = Get-Date
    $duration = $endTime - $startTime
    write-host "`nScan complete. Total time: $($duration.Minutes) minutes and $($duration.Seconds) seconds."
}
catch {
    Write-Error "An error occurred during the scan: $_"
}
finally {
    Write-Progress -Activity "Scanning Software" -Completed
    write-host "Thank you for using the Software Vulnerability Scanner. Have a great day!"
}  
