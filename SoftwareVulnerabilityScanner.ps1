# This is a simple script to scan for software vulnerabilities on a Windows 11 Machine.
# It will scan for vulnerabilities on the machine and return a list of software, software version,vulnerabilities, severity, and CVE citation.

# This script will use the following API:
# https://nvd.nist.gov/developers/request-an-api-key

# Software Vulnerability Scanner for Windows 11
# Uses NVD API for comprehensive vulnerability data

# Configuration
$apiKey = (Get-Content -Path "configVuln.json" | ConvertFrom-Json).NVDAPIKey    
$nvdApiBase = "https://services.nvd.nist.gov/rest/json/cves/2.0"

# Function to get installed software
function Get-InstalledSoftware {
    Write-Host "Getting installed software from multiple sources..."
    
    $results = @()
    
    # 1. Get Windows Store and MSI installed apps using winget
    Write-Host "Scanning winget..."
    $wingetOutput = winget list | Out-String
    $results += Parse-WingetOutput $wingetOutput
    
    # 2. Get programs from Program Files
    Write-Host "Scanning Program Files..."
    $programFiles = @(
        "${env:ProgramFiles}",
        "${env:ProgramFiles(x86)}"
    )
    
    foreach ($programPath in $programFiles) {
        Get-ChildItem -Path $programPath -Directory | ForEach-Object {
            try {
                $version = ""
                # Try to get version from executable if exists
                $exe = Get-ChildItem -Path $_.FullName -Filter "*.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($exe) {
                    $version = (Get-Item $exe.FullName).VersionInfo.FileVersion
                }
                
                $results += [PSCustomObject]@{
                    Name = $_.Name
                    ID = ""
                    Version = if ($version) { $version } else { "Unknown" }
                    InstallDate = $_.CreationTime
                    Source = "Program Files"
                }
            }
            catch {
                Write-Warning "Error processing $($_.FullName): $_"
            }
        }
    }
    
    # 3. Get from Registry
    Write-Host "Scanning Registry..."
    $registryPaths = @(
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*",
        "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*"
    )
    
    foreach ($path in $registryPaths) {
        Get-ItemProperty $path | ForEach-Object {
            if ($_.DisplayName) {
                $results += [PSCustomObject]@{
                    Name = $_.DisplayName
                    ID = $_.PSChildName
                    Version = $_.DisplayVersion
                    InstallDate = if ($_.InstallDate) {
                        try { [DateTime]::ParseExact($_.InstallDate, "yyyyMMdd", $null) }
                        catch { $null }
                    } else { $null }
                    Source = "Registry"
                }
            }
        }
    }
    
    # Remove duplicates based on Name
    $uniqueResults = $results | Sort-Object Name -Unique
    
    # Format and display the results
    $uniqueResults | Format-Table -AutoSize -Property @(
        @{Label="Software Name"; Expression={$_.Name}},
        @{Label="Version"; Expression={$_.Version}},
        @{Label="Source"; Expression={$_.Source}},
        @{Label="Install Date"; Expression={
            if ($_.InstallDate) {
                $_.InstallDate.ToString("yyyy-MM-dd")
            } else {
                "Unknown"
            }
        }}
    )
    
    return $uniqueResults
}

# Helper function to parse winget output
function Parse-WingetOutput {
    param (
        [string]$wingetOutput
    )
    
    # Convert the output to an array of lines and clean it up
    $lines = $wingetOutput -split "`n" | Where-Object { $_ -match '\S' }
    
    # Find the header line (contains "Name" and "Version")
    $headerIndex = $lines | Select-Object -First 5 | 
        Where-Object { $_ -match 'Name.*Version' } |
        ForEach-Object { $lines.IndexOf($_) }
    
    # Get the separator line to determine column positions
    $separator = $lines[$headerIndex + 1]
    
    # Create regex pattern based on separator line
    $columnBreaks = @()
    $separator.ToCharArray() | ForEach-Object -Begin { $i = 0 } -Process {
        if ($_ -eq '-' -and ($i -eq 0 -or $separator[$i-1] -ne '-')) {
            $columnBreaks += $i
        }
        $i++
    }
    $columnBreaks += $separator.Length
    
    # Process each line after the separator
    $results = for ($i = $headerIndex + 2; $i -lt $lines.Count; $i++) {
        $line = $lines[$i]
        if ($line -match '^\s*$') { continue }
        
        try {
            # Safely get substrings with error checking
            $nameLength = $columnBreaks[1] - $columnBreaks[0]
            $idLength = $columnBreaks[2] - $columnBreaks[1]
            $versionLength = $columnBreaks[3] - $columnBreaks[2]
            
            if ($nameLength -gt 0 -and $line.Length -gt $columnBreaks[0]) {
                $name = $line.Substring($columnBreaks[0], [Math]::Min($nameLength, $line.Length - $columnBreaks[0])).Trim()
                $id = if ($idLength -gt 0 -and $line.Length -gt $columnBreaks[1]) {
                    $line.Substring($columnBreaks[1], [Math]::Min($idLength, $line.Length - $columnBreaks[1])).Trim()
                } else { "" }
                $version = if ($versionLength -gt 0 -and $line.Length -gt $columnBreaks[2]) {
                    $line.Substring($columnBreaks[2], [Math]::Min($versionLength, $line.Length - $columnBreaks[2])).Trim()
                } else { "" }
                
                [PSCustomObject]@{
                    Name = $name
                    ID = $id
                    Version = $version
                    InstallDate = (Get-Item (Get-Command ($name -replace '\s.*$','')).Source -ErrorAction SilentlyContinue).CreationTime
                    Source = "Winget"
                }
            }
        }
        catch {
            Write-Warning "Error processing line: $line"
            Write-Warning $_.Exception.Message
            continue
        }
    }
    
    return $results
}

# Function to query NVD API
function Get-VulnerabilityData {
    param (
        [string]$software,
        [string]$version
    )
    
    # Remove any special characters and trim the software name
    $cleanSoftware = $software -replace '[^\w\s]', '' -replace '\s+', ' '
    
    $uri = "$nvdApiBase?keywordSearch=$cleanSoftware&apiKey=$apiKey"
    
    try {
        # Add error handling for empty or null software names
        if ([string]::IsNullOrWhiteSpace($cleanSoftware)) {
            Write-Warning "Empty software name provided"
            return $null
        }

        $response = Invoke-RestMethod -Uri $uri -Method Get
        
        # Check if we got a valid response
        if ($response.vulnerabilities) {
            return $response.vulnerabilities | Where-Object {
                $_.cve.descriptions.value -like "*$cleanSoftware*"
            }
        } else {
            Write-Verbose "No vulnerabilities found for $cleanSoftware"
            return $null
        }
    }
    catch {
        Write-Warning "Error querying NVD API for $cleanSoftware`: $_"
        return $null
    }
}

# Main scanning logic
write-host "Scanning for installed software..."
$startTime = Get-Date

try {
    $installedSoftware = Get-InstalledSoftware
    if ($null -eq $installedSoftware) {
        throw "No software found"
    }
    
    $totalApps = ($installedSoftware | Measure-Object).Count
    write-host "`nFound $totalApps applications to scan"

    write-host "`nScanning for vulnerabilities..."
    $progress = 0
    
    foreach ($software in $installedSoftware) {
        $progress++
        Write-Progress -Activity "Scanning Software" -Status "$($software.Name)" `
            -PercentComplete (($progress / $totalApps) * 100)
            
        if (![string]::IsNullOrWhiteSpace($software.Name)) {
            $vulnerabilityData = Get-VulnerabilityData -software $software.Name -version $software.Version
            if ($vulnerabilityData) {
                Write-Host "`nFound vulnerabilities for $($software.Name):"
                $vulnerabilityData | Select-Object -Property Name, Version, Vulnerability, Severity, CVE | 
                    Format-Table -AutoSize
            }
        }
        
        # Add delay to respect API rate limits
        Start-Sleep -Milliseconds 1200  # ~50 requests per minute
    }

    $endTime = Get-Date
    $duration = $endTime - $startTime
    write-host "`nScan complete. Total time: $($duration.Minutes) minutes and $($duration.Seconds) seconds."
}
catch {
    Write-Error "An error occurred during the scan: $_"
}
finally {
    Write-Progress -Activity "Scanning Software" -Completed
    write-host "Thank you for using the Software Vulnerability Scanner. Have a great day!"
}  
